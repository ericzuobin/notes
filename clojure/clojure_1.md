####REPL定义：
- 读入(Read)   
- 求值(Eval)  
- 输出(Print) 
- 循环(Loop)

####什么叫做函数
- 函数其实就是包号了一些数据的Clojure列表

####apply函数
- 它以提供给他的集合参数来调用传给它的参数；比如(apply + [a b c])调用和(+ a b c) 是一样的。

####Clojure表达式调用规则
- 列表里面的第一个值是操作符，其余的都是这个操作符的参数。

####同像性
- 代码是由Clojure自身的数据结构:原子值(字符串、数字等)和集合的字面量来表示的。“代码即数据”

####read-string
- 一个对于尝试Clojure方便的函数read-string，这个函数做的是和read函数一样的事情，接受一个字符串作为参数
    (read-string "(+ 1 2)")
    ;=(+ 1 2)

####Clojure命名空间
- 当前命名空间
    两个冒号开头(::)
- 特定命名空间
    两个冒号开头同时包含/ 。 (::alias/key)

####符号（关键字）
- 符号不能以数字开头，但是可以为特殊字符。

####正则表达式
- \#开头的字符串为正则表达式

####注释
- 单行注释以分号开头
- 形式级别的注释 #_宏
    优点是可以加入调试信息，告诉reader忽略下一个Clojure形式(表达式).
    类似于comment函数，但是comment函数回存在始终为nil的返回值，可能抛出不必要的异常。

####集合字面量
- list                '(a b c) 
- vector            ['a 'b 12.5]
- map            {:key1 "value1" :key2 "value2"}    注：空格和逗号没有区别，可以使用空格来区分
- set            #{1 2 3}

####var不是变量
- var引用类型是一种不可修改的内存地址，从而可以保存任何值，通常用来定义常量或者函数。

####命名空间定义与查询
- ns关键字  
    *ns* 查询当前命名空间
    (ns foo) 创建命名空间
- 每个命名空间都会默认引入Clojure核心库clojure.core中所有的var。

####阻止求值 quote
- 阻止表达式求值
- '单引号也是阻止求值的关键字

####代码块do
- do会依次求职你传进来的所有表达式，并且把最后一个表达式的结果作为返回值。

####定义var：def
- 作用是在**当前**命名空间定义或者重定义一个var

####let绑定
- _下划线指定的let绑定是不关心它的绑定值的。
- 所有的本地绑定都是不可变的。避免大量的编程错误。
- let绑定可以在编译器进行解构，简化绑定数组抽取的操作。

####解构   let []
- 顺序解构    []里面对应的是[]
    (def v [12 45 66 [22 87]])
    最基本的解构：(let [[x y z] v])
    嵌套解构：(let [[x _ _ [y z]] v])    注：下划线表示忽略某个绑定
    保持剩下的元素：(let [ [x & rest] v ] rest)    ;=(45 66 [22 87]])
    保持被解构的值： :as关键字  (let \[[ x _ z :as original-vector] v]  (conj original-vector (+ x z)) ) ;=[12 45 66 [22 87] 78]
    
- map解构  []里面对应的是{}
    (def m {:a 5 :b 6 :c [1 88 9] :d 88})
    最基本的map解构： (let \[{ a :a b :b} m] (+ a b))  ;= 11
    map解构的是vector、字符串或者数组的话，key一个个是数组下标。
