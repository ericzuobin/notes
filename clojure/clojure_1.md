####何谓函数式编程:
- 操作不可变的值
	1. 使用简单抽象的不可变数据结构，而不是有可变状态的数据结构。
	2. 把函数本身当做值的一种，从而可以使用高阶函数
- 对数据进行声明式的处理，而不是命令式的控制，遍历
- 对函数进行递增式的组合，使用高阶函数以及不可变数据结构，在更高的抽象级别来解决复杂的问题。

> Java某些使用了函数式编程的例子：google的guava，Function Java类库等。


####值的重要性
- 个人理解
> 类似于避免引用传递修改值，避免修改堆内存。基于栈。Clojure提供的数据结构是不可变的，而且是高效的。不用担心使用复杂的锁机制而使代码变得复杂而低效。


####什么叫做函数
- 函数其实就是包号了一些数据的Clojure列表。
- 函数的本身就是值(高阶函数)，这样就可以将它作为参数传递给其它函数，同时也可以把函数作为返回值。
- 函数在Clojure里面是*头等公民*。
> 在Java中，代码只能存放于方法里面，方法必须存放于类里面，而且由于Java的反射机制，方法本身不能被当做一个变量或者值来直接引用。

~~~
;举个例子
;实现一个函数，要求可以调用其它函数两次，可以传入任何函数，任何参数
;Clojure实现

user=> ( defn call-twice [f x]
  #_=>   (f x)
  #_=>   (f x))
  #'user/call-twice

user=> (call-twice println 123)
123
123			
~~~


####REPL定义：
- 读入(Read)   
- 求值(Eval)  
- 输出(Print) 
- 循环(Loop)


####apply函数
- 它以提供给他的集合参数来调用传给它的参数；比如(apply + [a b c])调用和(+ a b c) 是一样的。

####Clojure表达式调用规则
- 列表里面的第一个值是操作符，其余的都是这个操作符的参数。

####同像性
- 代码是由Clojure自身的数据结构:原子值(字符串、数字等)和集合的字面量来表示的。“代码即数据”

####read-string
- 一个对于尝试Clojure方便的函数read-string，这个函数做的是和read函数一样的事情，接受一个字符串作为参数
    (read-string "(+ 1 2)")
    ;=(+ 1 2)

####Clojure命名空间
- 当前命名空间
    两个冒号开头(::)
- 特定命名空间
    两个冒号开头同时包含/ 。 (::alias/key)

####符号（关键字）
- 符号不能以数字开头，但是可以为特殊字符。

####正则表达式
- \#开头的字符串为正则表达式

####注释
- 单行注释以分号开头
- 形式级别的注释 #_宏
    优点是可以加入调试信息，告诉reader忽略下一个Clojure形式(表达式).
    类似于comment函数，但是comment函数回存在始终为nil的返回值，可能抛出不必要的异常。

####集合字面量
- list                '(a b c) 
- vector            ['a 'b 12.5]
- map            {:key1 "value1" :key2 "value2"}    注：空格和逗号没有区别，可以使用空格来区分
- set            #{1 2 3}

####var不是变量
- var引用类型是一种不可修改的内存地址，从而可以保存任何值，通常用来定义常量或者函数。

####命名空间定义与查询
- ns关键字  
    *ns* 查询当前命名空间
    (ns foo) 创建命名空间
- 每个命名空间都会默认引入Clojure核心库clojure.core中所有的var。

####阻止求值 quote
- 阻止表达式求值
- '单引号也是阻止求值的关键字

####代码块do
- do会依次求职你传进来的所有表达式，并且把最后一个表达式的结果作为返回值。

####定义var：def
- 作用是在**当前**命名空间定义或者重定义一个var

####let绑定
- _下划线指定的let绑定是不关心它的绑定值的。
- 所有的本地绑定都是不可变的。避免大量的编程错误。
- let绑定可以在编译器进行解构，简化绑定数组抽取的操作。

####解构   let []
- 顺序解构    []里面对应的是[]
    (def v [12 45 66 [22 87]])
    最基本的解构：(let [[x y z] v])
    嵌套解构：(let [[x _ _ [y z]] v])    注：下划线表示忽略某个绑定
    保持剩下的元素：(let [ [x & rest] v ] rest)    ;=(45 66 [22 87]])
    保持被解构的值： :as关键字  (let \[[ x _ z :as original-vector] v]  (conj original-vector (+ x z)) ) ;=[12 45 66 [22 87] 78]
    
- map解构  []里面对应的是{}
    (def m {:a 5 :b 6 :c [1 88 9] :d 88})
    最基本的map解构： (let \[{ a :a b :b} m] (+ a b))  ;= 11
    map解构的是vector、字符串或者数组的话，key一个个是数组下标。
