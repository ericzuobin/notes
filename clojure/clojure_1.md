####何谓函数式编程:
- 操作不可变的值
	1. 使用简单抽象的不可变数据结构，而不是有可变状态的数据结构。
	2. 把函数本身当做值的一种，从而可以使用高阶函数
- 对数据进行声明式的处理，而不是命令式的控制，遍历
- 对函数进行递增式的组合，使用高阶函数以及不可变数据结构，在更高的抽象级别来解决复杂的问题。

> Java某些使用了函数式编程的例子：google的guava，Function Java类库等。


####值的重要性
- 个人理解

> 类似于避免引用传递修改值，避免修改堆内存。基于栈。Clojure提供的数据结构是不可变的，而且是高效的。不用担心使用复杂的锁机制而使代码变得复杂而低效。


####什么叫做函数
- 函数其实就是包号了一些数据的Clojure列表。
- 函数的本身就是值(高阶函数)，这样就可以将它作为参数传递给其它函数，同时也可以把函数作为返回值。
- 函数在Clojure里面是*头等公民*。

> 在Java中，代码只能存放于方法里面，方法必须存放于类里面，而且由于Java的反射机制，方法本身不能被当做一个变量或者值来直接引用。

~~~Clojure
;举个例子
;实现一个函数，要求可以调用其它函数两次，可以传入任何函数，任何参数
;Clojure实现

user=> (defn call-twice [f x]
  #_=>   (f x)
  #_=>   (f x))
  #'user/call-twice

user=> (call-twice println 123)
123
123			
~~~

####介绍几个基本函数
- map函数
> 把一个或多个顺序集合转换成另外一个顺序集合的最基本的高阶函数。
> 同时map返回的序列是惰性的。

~~~Clojure
user=> (map clojure.string/lower-case ["Clojure" "Java"])
("clojure" "java")

user=> (map + [1 2 3] [4 5 6])
(5 7 9)
~~~

- reduce函数
> 应用一个函数把一个集合里的值转换成单个值的过程，叫做归约。

~~~Clojure
user=> (reduce max [0 -3 10 48])
48
;相当于
user=> (max (max (max 0 -3) 10) 48)
48
~~~

- 函数应用apply

>函数应用是不同于普通的函数的调用，给定一个函数，
以及要传给这个函数的参数序列，然后来调用这个函数的过程叫做函数调用。
支持调用的函数和参数是运行时才能确定的。

~~~Clojure
;给一个确定参数，和不定参数的例子
user=> (def args [1 2 3 4])
#'user/args
user=> (apply * 10 2 args)
480
~~~

- 偏函数应用 Partial

>把函数fa的一部分参数传给一个函数fa，这样创建一个新的函数fb，
这个函数fb需要的参数就是你没有传给那个函数fa的那些剩余参数。
相当于给fa固定了一些参数，剩下的参数往fb传即可。




####REPL定义：
- 读入(Read)   
- 求值(Eval)  
- 输出(Print)
- 循环(Loop)


####apply函数
- 它以提供给他的集合参数来调用传给它的参数；比如(apply + [a b c])调用和(+ a b c) 是一样的。

####Clojure表达式调用规则
- 列表里面的第一个值是操作符，其余的都是这个操作符的参数。

####同像性
- 代码是由Clojure自身的数据结构:原子值(字符串、数字等)和集合的字面量来表示的。“代码即数据”

####read-string
- 一个对于尝试Clojure方便的函数read-string，这个函数做的是和read函数一样的事情，接受一个字符串作为参数
    (read-string "(+ 1 2)")
    ;=(+ 1 2)

####Clojure命名空间
- 当前命名空间
    两个冒号开头(::)
- 特定命名空间
    两个冒号开头同时包含/ 。 (::alias/key)

####符号（关键字）
- 符号不能以数字开头，但是可以为特殊字符。

####正则表达式
- \#开头的字符串为正则表达式

####注释
- 单行注释以分号开头
- 形式级别的注释 \#宏
    优点是可以加入调试信息，告诉reader忽略下一个Clojure形式(表达式).
    类似于comment函数，但是comment函数回存在始终为nil的返回值，可能抛出不必要的异常。

####集合字面量
- list                '(a b c)
- vector            ['a 'b 12.5]
- map            {:key1 "value1" :key2 "value2"}    注：空格和逗号没有区别，可以使用空格来区分
{}是Clojure中空map的字面量。
- set            #{1 2 3}

####var不是变量
- var引用类型是一种不可修改的内存地址，从而可以保存任何值，通常用来定义常量或者函数。

####命名空间定义与查询
- ns关键字  
    *ns* 查询当前命名空间
    (ns foo) 创建命名空间
- 每个命名空间都会默认引入Clojure核心库clojure.core中所有的var。

####阻止求值 quote
- 阻止表达式求值
- '单引号也是阻止求值的关键字

####代码块do
- do会依次求职你传进来的所有表达式，并且把最后一个表达式的结果作为返回值。

####定义var：def
- 作用是在**当前**命名空间定义或者重定义一个var

####let绑定
- \_下划线指定的let绑定是不关心它的绑定值的。
- 所有的本地绑定都是不可变的。避免大量的编程错误。
- let绑定可以在编译器进行解构，简化绑定数组抽取的操作。

####解构   let []
- 顺序解构    []里面对应的是[]
    (def v [12 45 66 [22 87]])
    最基本的解构：(let [[x y z] v])
    嵌套解构：(let [[x _ _ [y z]] v])    注：下划线表示忽略某个绑定
    保持剩下的元素：(let [ [x & rest] v ] rest)    ;=(45 66 [22 87]])
    保持被解构的值： :as关键字  (let \[[ x _ z :as original-vector] v]  (conj original-vector (+ x z)) ) ;=[12 45 66 [22 87] 78]

- map解构  []里面对应的是{}
    (def m {:a 5 :b 6 :c [1 88 9] :d 88})
    最基本的map解构： (let \[{ a :a b :b} m] (+ a b))  ;= 11
    map解构的是vector、字符串或者数组的话，key一个个是数组下标。
